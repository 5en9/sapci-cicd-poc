name: Reusable iFlow Deploy

on:
  workflow_call:
    inputs:
      iflows:
        required: true
        type: string
      package_id:
        required: true
        type: string
      tenants:
        required: true
        type: string
      environment:
        required: true
        type: string
      test_environments:
        required: true
        type: string

jobs:
  prep_environment:
    name: Approve deployment to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - run: echo "This job is a placeholder for environment approval."


  prepare_package:
    name: Tenant ${{ matrix.tenant }}:Prepare Package 
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        tenant: ${{ fromJSON(inputs.tenants) }}
    needs: prep_environment
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq

      - name: Set API Key and OAuth Details for Package Creation
        id: set_api_key_and_oauth_package
        run: |
          # Get Secret base on environment and tenant. Secret is store on repository on the format CI_APISERVICEKEY_<environment>_<tenant>
          SECRET_NAME="CI_APISERVICEKEY_${{ inputs.environment }}_${{ matrix.tenant }}"
          echo "Debugging: SECRET_NAME is $SECRET_NAME"
          API_KEY_JSON=$(echo '${{ toJSON(secrets) }}' | jq -r ."$SECRET_NAME")
          echo "Debugging: API_KEY_JSON is ::add-mask::$API_KEY_JSON"
          if [ -z "$API_KEY_JSON" ] || [ "$API_KEY_JSON" == "null" ]; then
            echo "Error: Secret $SECRET_NAME not found for tenant ${{ matrix.tenant }}."
            exit 1
          fi        
          CLIENT_ID=$(echo "$API_KEY_JSON" | jq -r ".oauth.clientid")
          CLIENT_SECRET=$(echo "$API_KEY_JSON" | jq -r ".oauth.clientsecret")
          TOKEN_URL=$(echo "$API_KEY_JSON" | jq -r ".oauth.tokenurl")
          BASE_URL=$(echo "$API_KEY_JSON" | jq -r ".oauth.url")

          echo "CLIENT_ID=$CLIENT_ID" >> $GITHUB_ENV
          echo "CLIENT_SECRET=$CLIENT_SECRET" >> $GITHUB_ENV
          echo "TOKEN_URL=$TOKEN_URL" >> $GITHUB_ENV
          echo "BASE_URL=$BASE_URL" >> $GITHUB_ENV
          echo "API_KEY=$API_KEY_JSON" >> $GITHUB_ENV # This line sets the API_KEY environment variable

      - name: Check and Create Integration Package
        run: |
          PACKAGE_ID="${{ inputs.package_id }}"
          
          echo "Getting OAuth token..."
          TOKEN_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=client_credentials" \
            -d 'client_id=${{ env.CLIENT_ID }}' \
            -d 'client_secret=${{ env.CLIENT_SECRET }}' \
            "${{ env.TOKEN_URL }}")
          
          ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r ".access_token")
          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
            echo "Error: Failed to obtain access token."
            echo "Response: $TOKEN_RESPONSE"
            exit 1
          fi
          echo "::add-mask::$ACCESS_TOKEN" # Mask the access token
          echo "Access token obtained."

          echo "Checking if Integration Package '$PACKAGE_ID' exists..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            "${{ env.BASE_URL }}/api/v1/IntegrationPackages(Id='$PACKAGE_ID')")

          echo "HTTP Status Code: $HTTP_CODE"

          if [ "$HTTP_CODE" == "404" ]; then
            echo "Integration Package '$PACKAGE_ID' not found. Creating it..."
            CREATE_RESPONSE=$(curl -s -X POST \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              -H "Accept: application/json" \
              -d "{\"Id\": \"$PACKAGE_ID\", \"Name\": \"$PACKAGE_ID\", \"ShortText\": \"Automatically created by CI/CD pipeline\"}" \
              "${{ env.BASE_URL }}/api/v1/IntegrationPackages")
            
            echo "Create Package Response: $CREATE_RESPONSE"
            
            if echo "$CREATE_RESPONSE" | jq -e ".d.Id" > /dev/null; then
              echo "Integration Package '$PACKAGE_ID' created successfully."
            else
              echo "Error: Failed to create Integration Package '$PACKAGE_ID'."
              exit 1
            fi
          elif [ "$HTTP_CODE" == "200" ]; then
            echo "Integration Package '$PACKAGE_ID' already exists. Skipping creation."
          else
            echo "Error: Unexpected HTTP status code '$HTTP_CODE' when checking Integration Package existence."
            exit 1
          fi

  deploy:
    name: Tenant ${{ matrix.tenant }}:Deploy ${{ matrix.iflow_id }}
    needs: prepare_package
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        tenant: ${{ fromJSON(inputs.tenants) }}
        iflow_id: ${{ fromJSON(inputs.iflows) }}
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
            name: iflow-artifact-${{ matrix.iflow_id }}

      - name: Download and Setup Piper
        run: |
          curl -L https://github.com/SAP/jenkins-library/releases/latest/download/piper -o piper
          chmod +x piper
          echo "$(pwd)" >> $GITHUB_PATH

      - name: Create Zip Archive
        run: |
          cd iflows/${{ matrix.iflow_id }}
          zip -r ../../${{ matrix.iflow_id }}.zip .

      - name: Set API Key
        id: set_api_key
        run: |
          # Get Secret base on environment and tenant. Secret is store on repository on the format CI_APISERVICEKEY_<environment>_<tenant>
          SECRET_NAME="CI_APISERVICEKEY_${{ inputs.environment }}_${{ matrix.tenant }}"
          echo "Debugging: SECRET_NAME is $SECRET_NAME"
          API_KEY_JSON=$(echo '${{ toJSON(secrets) }}' | jq -r ."$SECRET_NAME")
          echo "Debugging: API_KEY_JSON is ::add-mask::$API_KEY_JSON"
          echo "API_KEY_JSON=$API_KEY_JSON" >> $GITHUB_ENV # This line sets the API_KEY_JSON environment variable

      - name: Upload iFlow
        id: deploy
        uses: SAP/project-piper-action@main
        with:
          step-name: integrationArtifactUpload
          flags: |
            --apiServiceKey ${{ env.API_KEY_JSON }}
            --filePath ${{ matrix.iflow_id }}.zip
            --integrationFlowId ${{ matrix.iflow_id }}
            --integrationFlowName ${{ matrix.iflow_id }}
            --packageId ${{ inputs.package_id }}
            --verbose true

      - name: Update Configuration and Deploy
        run: |
          # Define file paths
          PROPDEF_FILE="iflows/${{ matrix.iflow_id }}/src/main/resources/parameters.propdef"
          GLOBAL_CONFIG_FILE="config/parameters-${{ inputs.environment }}.prop"
          IFLOW_CONFIG_FILE="iflows/${{ matrix.iflow_id }}/src/main/resources/parameters-${{ inputs.environment }}.prop"
          IFLOW_DEFAULT_CONFIG_FILE="iflows/${{ matrix.iflow_id }}/src/main/resources/parameters.prop"

          # Check if the definition file exists. If not, there are no parameters to configure.
          if [ ! -f "$PROPDEF_FILE" ]; then
            echo "Parameter definition file not found: $PROPDEF_FILE. Skipping configuration."
          else
            echo "Reading parameter definitions from $PROPDEF_FILE"
            
            # Correctly read parameter names from XML, handling potential CR characters
            PARAMS=$(grep -oP '<name>\K[^<]+' "$PROPDEF_FILE" | tr -d '\r')

            for PARAM_NAME in $PARAMS; do
                echo "Processing parameter: '$PARAM_NAME'"
                PARAM_VALUE=""

                # Function to safely read property value
                get_prop() {
                    local file="$1"
                    local key="$2"
                    # Read file, remove CR, find key, and return value
                    if [ -f "$file" ]; then
                        grep -E "^${key}=" "$file" | tr -d '\r' | cut -d'=' -f2-
                    fi
                }

                # 1. Check for iFlow-specific override
                VALUE_CANDIDATE=$(get_prop "$IFLOW_CONFIG_FILE" "$PARAM_NAME")
                if [ -n "$VALUE_CANDIDATE" ]; then
                    PARAM_VALUE="$VALUE_CANDIDATE"
                    echo "  Found iFlow specific value."
                fi

                # 2. If not found, check for global value
                if [ -z "$PARAM_VALUE" ]; then
                    VALUE_CANDIDATE=$(get_prop "$GLOBAL_CONFIG_FILE" "$PARAM_NAME")
                    if [ -n "$VALUE_CANDIDATE" ]; then
                        PARAM_VALUE="$VALUE_CANDIDATE"
                        echo "  Found global value."
                    fi
                fi

                # 3. If not found, check for iflow default value
                if [ -z "$PARAM_VALUE" ]; then
                    VALUE_CANDIDATE=$(get_prop "$IFLOW_DEFAULT_CONFIG_FILE" "$PARAM_NAME")
                    if [ -n "$VALUE_CANDIDATE" ]; then
                        PARAM_VALUE="$VALUE_CANDIDATE"
                        echo "  Found iFlow default value."
                    fi
                fi
                
                # 3. If a value was found, update the configuration
                if [ -n "$PARAM_VALUE" ]; then
                  echo "  Attempting to update iFlow with Key: '$PARAM_NAME' and Value: '$PARAM_VALUE'"
                  output=$(piper integrationArtifactUpdateConfiguration \
                      --apiServiceKey '${{ env.API_KEY_JSON }}' \
                      --integrationFlowId "${{ matrix.iflow_id }}" \
                      --integrationFlowVersion "active" \
                      --parameterKey "$PARAM_NAME" \
                      --parameterValue "$PARAM_VALUE" \
                      --verbose true 2>&1)
                  exit_code=$?

                  echo "$output"

                  if [ $exit_code -ne 0 ]; then
                    if echo "$output" | grep -q -E "does not exist|not found for Integration Flow"; then
                      echo "Warning: Parameter '$PARAM_NAME' not found on iFlow. This is expected for package-level parameters. Skipping."
                    else
                      echo "Error: A critical error occurred during parameter update. Failing the step."
                      exit 1
                    fi
                  fi
                else
                  echo "  No value found for '$PARAM_NAME' in property files. Skipping."
                fi
            done
          fi
          
          echo "Configuration updated. Now deploying the iFlow..."
          piper integrationArtifactDeploy \
            --apiServiceKey '${{ env.API_KEY_JSON }}' \
            --integrationFlowId "${{ matrix.iflow_id }}" \
            --verbose true

      - name: Automated Testing
        if: contains(fromJSON(inputs.test_environments), inputs.environment)
        run: |
          echo "Running automated tests for environment ${{ inputs.environment }}..."
          # Add your testing commands here

  test:
    name: Tenant ${{ matrix.tenant }}:Test ${{ matrix.iflow_id }}
    if: contains(fromJSON(inputs.test_environments), inputs.environment)
    needs: deploy
    runs-on: ubuntu-latest
    strategy:
      fail-fast: true
      matrix:
        tenant: ${{ fromJSON(inputs.tenants) }}
        iflow_id: ${{ fromJSON(inputs.iflows) }}
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
            name: iflow-artifact-${{ matrix.iflow_id }}

      - name: Download, Setup and Run cpilint
        run: |
          curl -sL "https://api.github.com/repos/mwittrock/cpilint/releases/latest" | grep "browser_download_url.*.zip" | cut -d '"' -f 4 | xargs curl -sL -o cpilint.zip
          unzip cpilint.zip
          CPILINT_DIR=$(unzip -qql cpilint.zip | head -n1 | tr -s ' ' | cut -d' ' -f5-)
          chmod +x "${CPILINT_DIR}bin/cpilint"
          ${CPILINT_DIR}bin/cpilint -rules config/cpilint.xml -directory iflows/${{ matrix.iflow_id }}

          
